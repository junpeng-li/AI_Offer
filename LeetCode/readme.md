## 一.岛屿数量
### 1.[题目描述](https://leetcode-cn.com/problems/number-of-islands/submissions/)
给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。
你可以假设网格的四个边均被水包围。
### 2.解题思路
这个题其实就是找联合在一起的1有多少块，再说的直白一点就是寻找被0隔开了的1分散了几个地方。所以我们可以通过遍历矩阵的行和列去检查有多少1是联合在一起的，
递归搜索的时候，寻找当前这个值上下左右四个位置的值就可以了，如果是1就把这个值变成0 ，防止被再次遍历。  

### 此思路来自[jyd](https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/)
dfs方法： 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。
从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。  
终止条件：  
(i, j) 越过矩阵边界;  
grid[i][j] == 0，代表此分支已越过岛屿边界。  
搜索岛屿的同时，执行 grid[i][j] = '0'，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。  
主循环：  
遍历整个矩阵，当遇到 grid[i][j] == '1' 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。  
最终返回岛屿数 count 即可。  
